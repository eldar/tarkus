_ = require("underscore")

# Prototypal inheritance
if typeof Object.create != "function"
    Object.create = ->
        F = ->
        F.prototype = o
        new F

# Shared empty constructor function to aid in prototype-chain creation.
ctor = ->

_.mixin(

    # Classic inheritance (adapted from backbone)
    inherits: (superClass, protoProps, staticProps) ->

        # The constructor function for the new class is either defined by you
        # (the "constructor" property in your `extend` definition), or defaulted
        # by us to simply call `super()`.
        if protoProps && protoProps.hasOwnProperty("constructor")
            subClass = protoProps.constructor
        else
            subClass = ->
                superClass.apply(this, arguments)

        # Set the prototype chain to inherit from `superClass`, without calling
        # `superClass`'s constructor function.
        ctor.prototype = superClass.prototype
        subClass.prototype = new ctor()

        # Add prototype properties (instance properties) to the subClass,
        # if supplied.
        _.extend(subClass.prototype, protoProps) if protoProps

        # Add static properties to the constructor function, if supplied.
        _.extend(subClass, staticProps) if staticProps?

        # Correctly set subClass's `prototype.constructor`, for `instanceof`.
        subClass.prototype.constructor = subClass
        
        # Convenience reference to super constructor
        subClass.prototype.super = superClass
        
        # Set a convenience property in case the superClass's prototype is needed later.
        subClass.superProto = superClass.prototype    
         
        return subClass
    
    isUndefinedOrNull: (value) ->
        not value?
        
    findIndex: (array, pred) ->
        for e, i in array
            return i if pred e
        -1
    
    # Inserts elements of the source array at the specified index
    # into the target array. If the position is not specified, the elements of the source array
    # will be appended to the end of the target array.    
    insert: (target, source, index) ->    
        len = source.length                
        if len > 0
            index = target.length if _.isUndefined(index)            
            target.length += len
            
            _.move(target, index + len, index, target.len - index)
                 
            `for (var i = 0; i < len; ++i, ++index)
                target[index] = source[i];`
        return
    
    # Copies count elements of the supplied array from sourceIndex to
    # targetIndex. Target and source array segments may overlap.  
    move: (array, targetIndex, sourceIndex, count) ->
        if _.isUndefined(count)
            count = array.length - sourceIndex
        else if targetIndex == sourceIndex || count == 0
            return;
            
        if targetIndex < sourceIndex
            `for (; count > 0; --count)
                array[targetIndex++] = array[sourceIndex++];`
        else
            targetIndex += count;
            sourceIndex += count;
            `for (; count > 0; --count)
                array[targetIndex--] = array[sourceIndex--];`
        return
)

exports._ = _;
