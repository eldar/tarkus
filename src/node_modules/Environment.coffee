fs = require "fs"
async = require "async"
pathUtil = require "path"
_ = (require "Global")._

exports.Project = class Project
    constructor: (name, dir) ->

exports.Environment = class Environment
    fileName: ".tarkus"
    
    constructor: ({dir}) ->
        # storing dir redundantly for posix FS idiocy
        @_dir = dir
        @_path = pathUtil.join(dir, @fileName)
        @_data = 
            projects: []
        
    path: -> @_path   
       
    create: ({overwrite, callback}) ->
    
        async.series [
            -> (callback)
                fs.open @_path, "w", (err, fd) ->
                    callback err
            -> 
        ]
        
        fs.open @_path, "w", (err, fd) ->
            if err
                console.log "Wow #{err}"
                callback err
            else
                fs.close fd, (err) -> callback(err)                    
    
    load: ({create, callback}) ->
        fs.readFile @_path, (err, data) =>
            if err
                if err.code == "ENOENT" && create
                    # pass the callback onto "create"
                    @create { callback: callback }       
                else
                    callback err     
            else
                @_data = data
                callback null, @
                        
    save: ->
        fs.writeFileSync(@_path, @_data)
              
    addProjectEntry: ({name, dir}) ->
        @_data.projects.push
            name: name
            dir: dir
      
    removeProjectEntry: ({name}) ->
        idx = _.find(@_data.projects, (project) -> name == project.name)
        if idx < 0
            throw new Error "Environment has no project #{name}"
  
    eachProjectEntry: (callback, pred) ->
        callback(project, i) for project, i in @_data.projects when pred
        
exports.load = (options) ->
    env = new Environment options
    env.load options
 
        
    
       

        

